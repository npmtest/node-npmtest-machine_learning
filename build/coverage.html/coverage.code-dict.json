{"/home/travis/build/npmtest/node-npmtest-machine_learning/test.js":"/* istanbul instrument in package npmtest_machine_learning */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-machine_learning/lib.npmtest_machine_learning.js":"/* istanbul instrument in package npmtest_machine_learning */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_machine_learning = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_machine_learning = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-machine_learning/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-machine_learning && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_machine_learning */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_machine_learning\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_machine_learning.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_machine_learning.rollup.js'] =\n            local.assetsDict['/assets.npmtest_machine_learning.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_machine_learning.__dirname + '/lib.npmtest_machine_learning.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-machine_learning/node_modules/machine_learning/lib/machine_learning.js":"/**\r\n * Created by joonkukang on 2014. 1. 18..\r\n */\r\n\r\n'use strict';\r\n\r\nlet ml = module.exports;\r\n\r\nml.kmeans = require('./kmeans');\r\n\r\nml.KNN = require('./knn');\r\n\r\nml.SVM = require('./svm');\r\n\r\nml.nmf = require('./nmf');\r\n\r\nml.optimize = require('./optimize');\r\n\r\nml.MLP = require('./mlp');\r\n\r\nml.DecisionTree = require('./DecisionTree');\r\n\r\nml.LogisticRegression = require('./LogisticRegression');\r\n","/home/travis/build/npmtest/node-npmtest-machine_learning/node_modules/machine_learning/lib/kmeans.js":"/**\r\n * Created by joonkukang on 2014. 1. 16..\r\n */\r\nvar math = require('./utils').math;\r\nlet Kmeans = module.exports;\r\n\r\nKmeans.cluster = function(options) {\r\n    var data = options['data'];\r\n    var k = options['k'];\r\n    var distance = getDistanceFunction(options['distance']);\r\n    var epochs = options['epochs'];\r\n    var init_using_data = options['init_using_data'];\r\n    if(typeof init_using_data === \"undefined\");\r\n        init_using_data = true;\r\n    var means = getRandomMeans(data,k, init_using_data);\r\n\r\n    var epoch, i, j, l;\r\n    var clusters = [];\r\n    for(i=0 ; i<k ; i++)\r\n        clusters.push([]);\r\n\r\n    for(epoch=0 ; epoch<epochs ; epoch++) {\r\n        clusters = [];\r\n        for(i=0 ; i<k ; i++)\r\n            clusters.push([]);\r\n\r\n        // Find which centroid is the closest for each row\r\n        for(i=0 ; i<data.length ; i++) {\r\n            var bestmatch = 0;\r\n            for(j=0 ; j<k ; j++) {\r\n                if(distance(means[j],data[i]) < distance(means[bestmatch],data[i])) bestmatch = j;\r\n            }\r\n            clusters[bestmatch].push(i);\r\n        }\r\n\r\n        // Move the centroids to the average of their members\r\n        for(i=0 ; i<k ; i++) {\r\n            var avgs = [];\r\n            for(j=0 ; j<data[0].length ; j++)\r\n                avgs.push(0.0);\r\n            if(clusters[i].length > 0) {\r\n                for(j=0 ; j<clusters[i].length ; j++) {\r\n                    for(l=0 ; l<data[0].length ; l++) {\r\n                        avgs[l] += data[clusters[i][j]][l];\r\n                    }\r\n                }\r\n                for(j=0 ; j<data[0].length ; j++) {\r\n                    avgs[j] /= clusters[i].length;\r\n                }\r\n                means[i] = avgs;\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        clusters : clusters,\r\n        means : means\r\n    };\r\n}\r\n\r\nvar getRandomMeans = function(data,k, init_using_data) {\r\n    var clusters = [];\r\n    if(init_using_data) {\r\n        var cluster_index = math.range(data.length);\r\n        cluster_index = math.shuffle(cluster_index);\r\n        for(i=0 ; i<k ; i++) {\r\n            clusters.push(data[cluster_index[i]]);\r\n        }\r\n    } else {\r\n        var i,j;\r\n        var ranges = [];\r\n        for(i=0 ; i<data[0].length ; i++) {\r\n            var min = data[0][i] , max = data[0][i];\r\n            for(j=0 ; j<data.length ; j++) {\r\n                if(data[j][i] < min) min = data[j][i];\r\n                if(data[j][i] > max) max = data[j][i];\r\n            }\r\n            ranges.push([min,max]);\r\n        }\r\n        for(i=0 ; i<k ; i++) {\r\n            var cluster = [];\r\n            for(j=0 ; j<data[0].length;j++) {\r\n                cluster.push(Math.random() * (ranges[j][1] - ranges[j][0]) + ranges[j][0]);\r\n            }\r\n            clusters.push(cluster);\r\n        }\r\n    }\r\n    return clusters;\r\n}\r\n\r\n\r\nfunction getDistanceFunction(options) {\r\n    if(typeof options === 'undefined') {\r\n        return math.euclidean;\r\n    } else if (typeof options === 'function') {\r\n        return options;\r\n    } else if (options['type'] === 'euclidean') {\r\n        return math.euclidean;\r\n    } else if (options['type'] === 'pearson') {\r\n        return math.pearson;\r\n    }\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-machine_learning/node_modules/machine_learning/lib/utils.js":"/**\r\n * Created by joonkukang on 2014. 1. 18..\r\n */\r\nlet utils = module.exports;\r\n\r\nutils.math = require('./math');\r\n\r\nutils.isNumber = function(n) {\r\n    return !isNaN(parseFloat(n)) && isFinite(n);\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-machine_learning/node_modules/machine_learning/lib/math.js":"/**\r\n * Created by joonkukang on 2014. 1. 12..\r\n */\r\nlet m = module.exports;\r\n\r\nm.randn = function() {\r\n    // generate random guassian distribution number. (mean : 0, standard deviation : 1)\r\n    var v1, v2, s;\r\n\r\n    do {\r\n        v1 = 2 * Math.random() - 1;   // -1.0 ~ 1.0 까지의 값\r\n        v2 = 2 * Math.random() - 1;   // -1.0 ~ 1.0 까지의 값\r\n        s = v1 * v1 + v2 * v2;\r\n    } while (s >= 1 || s == 0);\r\n\r\n    s = Math.sqrt( (-2 * Math.log(s)) / s );\r\n    return v1 * s;\r\n}\r\n\r\nm.shape = function(mat) {\r\n    var row = mat.length;\r\n    var col = mat[0].length;\r\n    return [row,col];\r\n};\r\n\r\nm.addVec = function(vec1, vec2) {\r\n    if(vec1.length === vec2.length) {\r\n        var result = [];\r\n        var i;\r\n        for(i=0;i<vec1.length;i++)\r\n            result.push(vec1[i]+vec2[i]);\r\n        return result;\r\n    } else {\r\n        throw new Error(\"Length Error : not same.\")\r\n    }\r\n}\r\n\r\nm.minusVec = function(vec1,vec2) {\r\n    if(vec1.length === vec2.length) {\r\n        var result = [];\r\n        var i;\r\n        for(i=0;i<vec1.length;i++)\r\n            result.push(vec1[i]-vec2[i]);\r\n        return result;\r\n    } else {\r\n        throw new Error(\"Length Error : not same.\")\r\n    }\r\n};\r\n\r\nm.addMatScalar = function(mat,scalar) {\r\n    var row = m.shape(mat)[0];\r\n    var col = m.shape(mat)[1];\r\n    var i , j,result = [];\r\n    for(i=0 ; i<row ; i++) {\r\n        var rowVec = [];\r\n        for(j=0 ; j<col ; j++) {\r\n            rowVec.push(mat[i][j] + scalar);\r\n        }\r\n        result.push(rowVec);\r\n    }\r\n    return result;\r\n}\r\n\r\nm.addMatVec = function(mat,vec) {\r\n    if(mat[0].length === vec.length) {\r\n        var result = [];\r\n        var i;\r\n        for(i=0;i<mat.length;i++)\r\n            result.push(m.addVec(mat[i],vec));\r\n        return result;\r\n    } else {\r\n        throw new Error(\"Length Error : not same.\")\r\n    }\r\n}\r\n\r\nm.minusMatVec = function(mat,vec) {\r\n    if(mat[0].length === vec.length) {\r\n        var result = [];\r\n        var i;\r\n        for(i=0;i<mat.length;i++)\r\n            result.push(m.minusVec(mat[i],vec));\r\n        return result;\r\n    } else {\r\n        throw new Error(\"Length Error : not same.\")\r\n    }\r\n}\r\n\r\nm.addMat = function (mat1, mat2) {\r\n    if ((mat1.length === mat2.length) && (mat1[0].length === mat2[0].length)) {\r\n        var result = new Array(mat1.length);\r\n        for (var i = 0; i < mat1.length; i++) {\r\n            result[i] = new Array(mat1[i].length);\r\n            for (var j = 0; j < mat1[i].length; j++) {\r\n                result[i][j] = mat1[i][j] + mat2[i][j];\r\n            }\r\n        }\r\n        return result;\r\n    } else {\r\n        throw new Error('Matrix mismatch.');\r\n    }\r\n};\r\n\r\nm.minusMat = function(mat1, mat2) {\r\n    if ((mat1.length === mat2.length) && (mat1[0].length === mat2[0].length)) {\r\n        var result = new Array(mat1.length);\r\n        for (var i = 0; i < mat1.length; i++) {\r\n            result[i] = new Array(mat1[i].length);\r\n            for (var j = 0; j < mat1[i].length; j++) {\r\n                result[i][j] = mat1[i][j] - mat2[i][j];\r\n            }\r\n        }\r\n        return result;\r\n    } else {\r\n        throw new Error('Matrix mismatch.');\r\n    }\r\n}\r\n\r\nm.transpose = function (mat) {\r\n    var result = new Array(mat[0].length);\r\n    for (var i = 0; i < mat[0].length; i++) {\r\n        result[i] = new Array(mat.length);\r\n        for (var j = 0; j < mat.length; j++) {\r\n            result[i][j] = mat[j][i];\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nm.dotVec = function (vec1, vec2) {\r\n    if (vec1.length === vec2.length) {\r\n        var result = 0;\r\n        for (var i = 0; i < vec1.length; i++) {\r\n            result += vec1[i] * vec2[i];\r\n        }\r\n        return result;\r\n    } else {\r\n        throw new Error(\"Vector mismatch\");\r\n    }\r\n};\r\n\r\nm.outerVec = function (vec1,vec2) {\r\n    var mat1 = m.transpose([vec1]);\r\n    var mat2 = [vec2];\r\n    return m.mulMat(mat1,mat2);\r\n};\r\n\r\nm.mulVecScalar = function(vec,scalar) {\r\n    var i, result = [];\r\n    for(i=0;i<vec.length;i++)\r\n        result.push(vec[i]*scalar);\r\n    return result;\r\n};\r\n\r\nm.mulMatScalar = function(mat,scalar) {\r\n    var row = m.shape(mat)[0];\r\n    var col = m.shape(mat)[1];\r\n    var i , j,result = [];\r\n    for(i=0 ; i<row ; i++) {\r\n        var rowVec = [];\r\n        for(j=0 ; j<col ; j++) {\r\n            rowVec.push(mat[i][j] * scalar);\r\n        }\r\n        result.push(rowVec);\r\n    }\r\n    return result;\r\n};\r\n\r\nm.mulMatElementWise = function(mat1, mat2) {\r\n    if (mat1.length === mat2.length && mat1[0].length === mat2[0].length) {\r\n        var result = new Array(mat1.length);\r\n\r\n        for (var x = 0; x < mat1.length; x++) {\r\n            result[x] = new Array(mat1[0].length);\r\n        }\r\n\r\n        for (var i = 0; i < result.length; i++) {\r\n            for (var j = 0; j < result[i].length; j++) {\r\n                result[i][j] = mat1[i][j] * mat2[i][j]\r\n            }\r\n        }\r\n        return result;\r\n    } else {\r\n        throw new Error(\"Matrix shape error : not same\");\r\n    }\r\n};\r\n\r\nm.mulMat = function (mat1, mat2) {\r\n    if (mat1[0].length === mat2.length) {\r\n        var result = new Array(mat1.length);\r\n\r\n        for (var x = 0; x < mat1.length; x++) {\r\n            result[x] = new Array(mat2[0].length);\r\n        }\r\n\r\n\r\n        var mat2_T = m.transpose(mat2);\r\n        for (var i = 0; i < result.length; i++) {\r\n            for (var j = 0; j < result[i].length; j++) {\r\n                result[i][j] = m.dotVec(mat1[i],mat2_T[j]);\r\n            }\r\n        }\r\n        return result;\r\n    } else {\r\n        throw new Error(\"Array mismatch\");\r\n    }\r\n};\r\n\r\nm.sumVec = function(vec) {\r\n    var sum = 0;\r\n    var i = vec.length;\r\n    while (i--) {\r\n        sum += vec[i];\r\n    }\r\n    return sum;\r\n};\r\n\r\nm.sumMat = function(mat) {\r\n    var sum = 0;\r\n    var i = mat.length;\r\n    while (i--) {\r\n        for(var j=0;j<mat[0].length;j++)\r\n          sum += mat[i][j];\r\n    }\r\n    return sum;\r\n};\r\n\r\nm.sumMatAxis = function(mat,axis) {\r\n    // default axis 0;\r\n    // axis 0 : mean of col vector . axis 1 : mean of row vector\r\n    if(axis === 1) {\r\n        var row = m.shape(mat)[0];\r\n        var i ;\r\n        var result = [];\r\n        for(i=0 ; i<row; i++)\r\n            result.push(m.sumVec(mat[i]));\r\n        return result;\r\n    } else {\r\n        mat_T = m.transpose(mat);\r\n        return m.sumMatAxis(mat_T,1);\r\n    }\r\n};\r\n\r\nm.meanVec = function(vec) {\r\n    return 1. * m.sumVec(vec) / vec.length;\r\n};\r\n\r\nm.meanMat = function(mat) {\r\n    var row = mat.length;\r\n    var col = mat[0].length;\r\n    return 1. * m.sumMat(mat) / (row * col);\r\n};\r\n\r\nm.meanMatAxis = function(mat,axis) {\r\n    // default axis 0;\r\n    // axis 0 : mean of col vector . axis 1 : mean of row vector\r\n    if(axis === 1) {\r\n        var row = m.shape(mat)[0];\r\n        var i ;\r\n        var result = [];\r\n        for(i=0 ; i<row; i++)\r\n            result.push(m.meanVec(mat[i]));\r\n        return result;\r\n    } else {\r\n        mat_T = m.transpose(mat);\r\n        return m.meanMatAxis(mat_T,1);\r\n    }\r\n};\r\n\r\nm.squareVec = function(vec) {\r\n    var squareVec = [];\r\n    var i;\r\n    for(i=0;i<vec.length;i++) {\r\n        squareVec.push(vec[i]*vec[i]);\r\n    }\r\n    return squareVec;\r\n};\r\n\r\nm.squareMat = function(mat) {\r\n    var squareMat = [];\r\n    var i;\r\n    for(i=0;i<mat.length;i++) {\r\n        squareMat.push(m.squareVec(mat[i]));\r\n    }\r\n    return squareMat;\r\n};\r\n\r\nm.minVec = function(vec) {\r\n    var min = vec[0];\r\n    var i = vec.length;\r\n    while (i--) {\r\n        if (vec[i] < min)\r\n            min = vec[i];\r\n    }\r\n    return min;\r\n};\r\n\r\nm.maxVec = function(vec) {\r\n    var max = vec[0];\r\n    var i = vec.length;\r\n    while (i--) {\r\n        if (vec[i] > max)\r\n            max = vec[i];\r\n    }\r\n    return max;\r\n}\r\n\r\nm.minMat = function(mat) {\r\n    var min = mat[0][0];\r\n    var i = mat.length;\r\n    while (i--) {\r\n        for(var j=0;j<mat[0].length;j++) {\r\n            if(mat[i][j] < min)\r\n                min = mat[i][j];\r\n        }\r\n    }\r\n    return min;\r\n};\r\n\r\nm.maxMat = function(mat) {\r\n    var max = mat[0][0];\r\n    var i = mat.length;\r\n    while (i--) {\r\n        for(var j=0;j<mat[0].length;j++) {\r\n            if(mat[i][j] < max)\r\n                max = mat[i][j];\r\n        }\r\n    }\r\n    return max;\r\n};\r\n\r\nm.zeroVec = function(n) {\r\n    var vec = [];\r\n    while(vec.length < n)\r\n        vec.push(0);\r\n    return vec;\r\n};\r\n\r\nm.zeroMat = function(row,col) {\r\n    var mat = [];\r\n    while(mat.length < row)\r\n        mat.push(m.zeroVec(col));\r\n    return mat;\r\n};\r\n\r\nm.oneVec = function(n) {\r\n    var vec = [];\r\n    while(vec.length < n)\r\n        vec.push(1);\r\n    return vec;\r\n};\r\n\r\nm.oneMat = function(row,col) {\r\n    var mat = [];\r\n    while(mat.length < row)\r\n        mat.push(m.oneVec(col));\r\n    return mat;\r\n};\r\n\r\nm.randVec = function(n,lower,upper) {\r\n    lower = (typeof lower !== 'undefined') ? lower : 0;\r\n    upper = (typeof upper !== 'undefined') ? upper : 1;\r\n    var vec = [];\r\n    while(vec.length < n)\r\n        vec.push(lower + (upper-lower) * Math.random());\r\n    return vec;\r\n};\r\n\r\nm.randMat = function(row,col,lower,upper) {\r\n    lower = (typeof lower !== 'undefined') ? lower : 0;\r\n    upper = (typeof upper !== 'undefined') ? upper : 1;\r\n    var mat = [];\r\n    while(mat.length < row)\r\n        mat.push(m.randVec(col,lower,upper));\r\n    return mat;\r\n};\r\n\r\nm.randnVec = function(n,mean,sigma) {\r\n    var vec = [];\r\n    while(vec.length < n)\r\n        vec.push(mean+sigma* m.randn());\r\n    return vec;\r\n};\r\n\r\nm.randnMat = function(row,col,mean,sigma) {\r\n    var mat = [];\r\n    while(mat.length < row)\r\n        mat.push(m.randnVec(col,mean,sigma));\r\n    return mat;\r\n};\r\n\r\nm.identity = function (n) {\r\n    var result = new Array(n);\r\n\r\n    for (var i = 0; i < n ; i++) {\r\n        result[i] = new Array(n);\r\n        for (var j = 0; j < n; j++) {\r\n            result[i][j] = (i === j) ? 1 : 0;\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nm.sigmoid = function(x) {\r\n    var sigmoid = (1. / (1 + Math.exp(-x)))\r\n    if(sigmoid ==1) {\r\n     //   console.warn(\"Something Wrong!! Sigmoid Function returns 1. Probably javascript float precision problem?\\nSlightly Controlled value to 1 - 1e-14\")\r\n        sigmoid = 0.99999999999999; // Javascript Float Precision Problem.. This is a limit of javascript.\r\n    } else if(sigmoid ==0) {\r\n      //  console.warn(\"Something Wrong!! Sigmoid Function returns 0. Probably javascript float precision problem?\\nSlightly Controlled value to 1e-14\")\r\n        sigmoid = 1e-14;\r\n    }\r\n    return sigmoid; // sigmoid cannot be 0 or 1;;\r\n};\r\n\r\nm.dSigmoid = function(x){\r\n    a = m.sigmoid(x);\r\n    return a * (1. - a);\r\n};\r\n\r\nm.probToBinaryMat = function(mat) {\r\n    var row = m.shape(mat)[0];\r\n    var col = m.shape(mat)[1];\r\n    var i,j;\r\n    var result = [];\r\n\r\n    for(i=0;i<row;i++) {\r\n        var rowVec = [];\r\n        for(j=0;j<col;j++) {\r\n            if(Math.random() < mat[i][j])\r\n                rowVec.push(1);\r\n            else\r\n                rowVec.push(0);\r\n        }\r\n        result.push(rowVec);\r\n    }\r\n    return result;\r\n};\r\n\r\nm.activateVec = function(vec,activation) {\r\n    var i, result = [];\r\n    for(i=0;i<vec.length;i++)\r\n        result.push(activation(vec[i]));\r\n    return result;\r\n};\r\n\r\nm.activateMat = function(mat,activation) {\r\n    var row = m.shape(mat)[0];\r\n    var col = m.shape(mat)[1];\r\n    var i, j,result = [];\r\n    for(i=0;i<row;i++) {\r\n        var rowVec = [];\r\n        for(j=0;j<col;j++)\r\n            rowVec.push(activation(mat[i][j]));\r\n        result.push(rowVec);\r\n    }\r\n    return result;\r\n};\r\n\r\nm.activateTwoVec = function(vec1, vec2,activation) {\r\n    if (vec1.length === vec2.length) {\r\n        var result = new Array(vec1.length);\r\n        for (var i = 0; i < result.length; i++) {\r\n            result[i] = activation(vec1[i],vec2[i]);\r\n        }\r\n        return result;\r\n    } else {\r\n        throw new Error(\"Matrix shape error : not same\");\r\n    }\r\n};\r\n\r\nm.activateTwoMat = function(mat1, mat2,activation) {\r\n    if (mat1.length === mat2.length && mat1[0].length === mat2[0].length) {\r\n        var result = new Array(mat1.length);\r\n\r\n        for (var x = 0; x < mat1.length; x++) {\r\n            result[x] = new Array(mat1[0].length);\r\n        }\r\n\r\n        for (var i = 0; i < result.length; i++) {\r\n            for (var j = 0; j < result[i].length; j++) {\r\n                result[i][j] = activation(mat1[i][j],mat2[i][j]);\r\n            }\r\n        }\r\n        return result;\r\n    } else {\r\n        throw new Error(\"Matrix shape error : not same\");\r\n    }\r\n};\r\n\r\nm.fillVec = function(n,value) {\r\n    var vec = [];\r\n    while(vec.length < n)\r\n        vec.push(value);\r\n    return vec;\r\n};\r\n\r\nm.fillMat = function(row,col,value) {\r\n    var mat = [];\r\n    while(mat.length < row) {\r\n        var rowVec = [];\r\n        while(rowVec.length < col)\r\n            rowVec.push(value);\r\n        mat.push(rowVec);\r\n    }\r\n    return mat;\r\n};\r\n\r\nm.softmaxVec = function(vec) {\r\n    var max = m.maxVec(vec);\r\n    var preSoftmaxVec = m.activateVec(vec,function(x) {return Math.exp(x - max);})\r\n    return m.activateVec(preSoftmaxVec,function(x) {return x/ m.sumVec(preSoftmaxVec)})\r\n};\r\n\r\nm.softmaxMat = function(mat) {\r\n    var result=[], i;\r\n    for(i=0 ; i<mat.length ; i++)\r\n        result.push(m.softmaxVec(mat[i]));\r\n    return result;\r\n};\r\n\r\nm.randInt = function(min,max) {\r\n  var rand = Math.random() * (max - min + 0.9999) + min\r\n  return Math.floor(rand);\r\n}\r\n\r\nm.normalizeVec = function(vec) {\r\n    var i;\r\n    var newVec = [],tot = 0;\r\n    for(i=0; i<vec.length; i++)\r\n        tot += vec[i];\r\n    for(i=0; i<vec.length;i++)\r\n        newVec.push(1.*vec[i]/tot);\r\n    return newVec;\r\n};\r\n\r\nm.euclidean = function(x1,x2) {\r\n    var i;\r\n    var distance = 0;\r\n    for(i=0 ; i<x1.length; i++) {\r\n        var dx = x1[i] - x2[i];\r\n        distance += dx * dx;\r\n    }\r\n    return Math.sqrt(distance);\r\n};\r\n\r\nm.pearson = function(x, y)\r\n{\r\n    var xy = [];\r\n    var x2 = [];\r\n    var y2 = [];\r\n\r\n    for(var i=0; i<x.length; i++)\r\n    {\r\n        xy.push(x[i] * y[i]);\r\n        x2.push(x[i] * x[i]);\r\n        y2.push(y[i] * y[i]);\r\n    }\r\n\r\n    var sum_x = 0;\r\n    var sum_y = 0;\r\n    var sum_xy = 0;\r\n    var sum_x2 = 0;\r\n    var sum_y2 = 0;\r\n\r\n    for(var i=0; i<x.length; i++)\r\n    {\r\n        sum_x += x[i];\r\n        sum_y += y[i];\r\n        sum_xy += xy[i];\r\n        sum_x2 += x2[i];\r\n        sum_y2 += y2[i];\r\n    }\r\n\r\n    var step1 = (x.length * sum_xy) - (sum_x * sum_y);\r\n    var step2 = (x.length * sum_x2) - (sum_x * sum_x);\r\n    var step3 = (x.length * sum_y2) - (sum_y * sum_y);\r\n    var step4 = Math.sqrt(step2 * step3);\r\n    var answer = step1 / step4;\r\n\r\n    return answer;\r\n};\r\n\r\nm.getNormVec = function(vec) {\r\n    var i;\r\n    var sqsum = 0;\r\n    for(i=0; i<vec.length; i++)\r\n        sqsum += vec[i] * vec[i];\r\n    return Math.sqrt(sqsum);\r\n}\r\n\r\nm.gaussian = function(x, sigma) {\r\n    sigma = sigma || 10.0;\r\n    return Math.exp(-1.*x*x/(2*sigma*sigma));\r\n}\r\n\r\nm.meanVecs = function(vecs) {\r\n    var sum = m.zeroVec(vecs[0].length);\r\n    var i;\r\n    for(i=0; i<vecs.length; i++)\r\n        sum = m.addVec(sum,vecs[i]);\r\n    return m.activateVec(sum,function(x) {return 1.*x/vecs.length;});\r\n};\r\n\r\nm.covarianceVecs = function(vecs) {\r\n    var mat = m.zeroMat(vecs[0].length,vecs[0].length);\r\n    var meanVec = m.meanVecs(vecs);\r\n    var i;\r\n    for(i=0; i<vecs.length; i++) {\r\n        var a = m.minusVec(vecs[i],meanVec);\r\n        mat = m.addMat(mat, m.mulMat(m.transpose([a]),[a]));\r\n    }\r\n    return m.activateMat(mat,function(x) { return 1.*x/(vecs.length-1);});\r\n};\r\n\r\nm.shuffle = function(arr){\r\n    var o = [];\r\n    for(var i=0;i<arr.length;i++)\r\n        o.push(arr[i]); // deep copy\r\n    for(var j, x, i = o.length; i; j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);\r\n    return o;\r\n};\r\n\r\nm.range = function(start, end, step) {\r\n    var ret = [];\r\n    if(typeof step === \"undefined\")\r\n        step = 1;\r\n    if(typeof end === \"undefined\") {\r\n        end = start;\r\n        start = 0;\r\n    }\r\n    for(var i=start;i<end;i+=step)\r\n        ret.push(i);\r\n    return ret;\r\n};\r\n// For CRBM\r\n/*\r\nm.phi = function(mat,vec,low,high) {\r\n    var i;\r\n    var result = [];\r\n    for(i=0;i<mat.length;i++) {\r\n        result.push(m.activateTwoVec(mat[i],vec,function(x,y){return low+(high-low)* m.sigmoid(x*y);}))\r\n    }\r\n    return result;\r\n}\r\n*/\r\n","/home/travis/build/npmtest/node-npmtest-machine_learning/node_modules/machine_learning/lib/knn.js":"/**\r\n * Created by joonkukang on 2014. 1. 16..\r\n */\r\nvar math = require('./utils').math;\r\nlet KNN = module.exports = function (options) {\r\n    var self = this;\r\n    self.data = options['data'];\r\n    self.result = options['result'];\r\n}\r\n\r\nKNN.prototype.predict = function(options) {\r\n    var self = this;\r\n    var x = options['x'];\r\n    var k = options['k'] || 3;\r\n    var weightf = getWeightedFunction(options['weightf']);\r\n    var distance = getDistanceFunction(options['distance']);\r\n    var distanceList = [];\r\n    var i;\r\n    for(i=0; i<self.data.length; i++)\r\n        distanceList.push([distance(x,self.data[i]),i]);\r\n    distanceList.sort(function(a,b) {return a[0]-b[0];});\r\n    var avg = 0.0;\r\n    var totalWeight = 0, weight;\r\n    for(i=0; i<k; i++) {\r\n        var dist = distanceList[i][0];\r\n        var idx = distanceList[i][1];\r\n        weight = weightf(dist);\r\n        avg += weight * self.result[idx];\r\n        totalWeight += weight;\r\n    }\r\n\r\n    avg /= totalWeight;\r\n    return avg;\r\n};\r\n\r\nfunction getWeightedFunction(options) {\r\n    if(typeof options === 'undefined') {\r\n        return function(x) {\r\n            var sigma = 10.0;\r\n            return Math.exp(-1.*x*x/(2*sigma*sigma));\r\n        }\r\n    } else if(typeof options === 'function') {\r\n        return options;\r\n    } else if(options['type'] === 'gaussian') {\r\n        return function(x) {\r\n            var sigma = options['sigma'];\r\n            return Math.exp(-1.*x*x/(2*sigma*sigma));\r\n        }\r\n    } else if(options['type'] === 'none') {\r\n        return function(dist) {\r\n            return 1.0;\r\n        }\r\n    }\r\n}\r\n\r\nfunction getDistanceFunction(options) {\r\n    if(typeof options === 'undefined') {\r\n        return math.euclidean;\r\n    } else if (typeof options === 'function') {\r\n        return options;\r\n    } else if (options['type'] === 'euclidean') {\r\n        return math.euclidean;\r\n    } else if (options['type'] === 'pearson') {\r\n        return math.pearson;\r\n    }\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-machine_learning/node_modules/machine_learning/lib/svm.js":"/**\r\n * Created by joonkukang on 2014. 1. 16..\r\n */\r\n\r\n/* References : http://cs229.stanford.edu/materials/smo.pdf . simplified smo algorithm */\r\nvar math = require('./utils').math;\r\n\r\nlet SVM = module.exports = function (options) {\r\n    var self = this;\r\n    self.x = options['x'];\r\n    self.y = options['y'];\r\n};\r\n\r\nSVM.prototype.train = function (options) {\r\n    var self = this;\r\n    var C = options['C'] || 1.0;\r\n    var tol = options['tol'] || 1e-4;\r\n    var maxPasses = options['max_passes'] || 20;\r\n    var alphatol = options['alpha_tol'] || 1e-5;\r\n\r\n    self.kernel = getKernel(options['kernel']);\r\n    self.alphas = math.zeroVec(self.x.length);\r\n    self.b = 0;\r\n    var passes = 0, i;\r\n    var count=0;\r\n    while(passes < maxPasses) {\r\n        var numChangedAlphas = 0;\r\n\r\n        for(i=0; i<self.x.length; i++) {\r\n\r\n            var E_i = self.f(self.x[i]) - self.y[i];\r\n\r\n            if((self.y[i] * E_i < -tol && self.alphas[i] < C) || (self.y[i] * E_i > tol && self.alphas[i] >0)) {\r\n\r\n                // Randomly selects j (i != j)\r\n                var j = math.randInt(0,self.x.length-1);\r\n                if(i==j) j = (j+1) % self.x.length;\r\n\r\n                var E_j = self.f(self.x[j]) - self.y[j];\r\n                var alpha_i_old = self.alphas[i], alpha_j_old = self.alphas[j];\r\n\r\n                // Compute L,H\r\n                var L,H;\r\n                if(self.y[i] !== self.y[j]) {\r\n                    L = Math.max(0, self.alphas[j] - self.alphas[i]);\r\n                    H = Math.min(C, C + self.alphas[j] - self.alphas[i]);\r\n                } else {\r\n                    L = Math.max(0, self.alphas[j] + self.alphas[i] - C);\r\n                    H = Math.min(C, self.alphas[j] + self.alphas[i]);\r\n                }\r\n\r\n                if(L === H)\r\n                    continue;\r\n\r\n                // Compute ETA\r\n                var ETA = 2 * self.kernel(self.x[i],self.x[j]) - self.kernel(self.x[i],self.x[i]) - self.kernel(self.x[j],self.x[j]);\r\n                if(ETA >= 0)\r\n                    continue;\r\n\r\n                // Clip new value to alpha_j\r\n                self.alphas[j] -= 1.*self.y[j] * (E_i - E_j) / ETA;\r\n                if(self.alphas[j] > H)\r\n                    self.alphas[j] = H;\r\n                else if(self.alphas[j] < L)\r\n                    self.alphas[j] = L;\r\n\r\n                if(Math.abs(self.alphas[j] - alpha_j_old) < alphatol)\r\n                    continue;\r\n\r\n                // Clip new value to alpha_i\r\n                self.alphas[i] += self.y[i] * self.y[j] * (alpha_j_old - self.alphas[j]);\r\n\r\n                // update b\r\n                var b1 = self.b - E_i - self.y[i] * (self.alphas[i] - alpha_i_old) * self.kernel(self.x[i],self.x[i])\r\n                                - self.y[j] * (self.alphas[j] - alpha_j_old) * self.kernel(self.x[i],self.x[j]);\r\n                var b2 = self.b - E_j - self.y[i] * (self.alphas[i] - alpha_i_old) * self.kernel(self.x[i],self.x[j])\r\n                                - self.y[j] * (self.alphas[j] - alpha_j_old) * self.kernel(self.x[j],self.x[j]);\r\n\r\n                if(0 < self.alphas[i] && self.alphas[i] < C)\r\n                    self.b = b1;\r\n                else if(0 < self.alphas[j] && self.alphas[j] < C)\r\n                    self.b = b2;\r\n                else\r\n                    self.b = (b1+b2)/2.0;\r\n\r\n                numChangedAlphas ++ ;\r\n            } // end-if\r\n        } // end-for\r\n        if(numChangedAlphas == 0)\r\n            passes++;\r\n        else\r\n            passes = 0;\r\n    }\r\n}\r\n\r\nSVM.prototype.predict = function(x) {\r\n    var self = this;\r\n    if(self.f(x) >= 0)\r\n        return 1;\r\n    else\r\n        return -1;\r\n}\r\n\r\nSVM.prototype.f = function(x) {\r\n    var self = this;\r\n    var f = 0, j;\r\n    for(j=0; j<self.x.length; j++)\r\n        f += self.alphas[j] * self.y[j] * self.kernel(self.x[j],x);\r\n    f += self.b;\r\n    return f;\r\n}\r\n\r\nfunction getKernel (options) {\r\n    if(typeof options === 'undefined') {\r\n        return function(x,y) {\r\n            var sigma = 1.0;\r\n            return Math.exp(-1.*Math.pow(math.getNormVec(math.minusVec(x,y)),2)/(2*sigma*sigma));\r\n        }\r\n    } else if (typeof options === 'function') {\r\n        return options;\r\n    } else if (options['type'] === 'gaussian') {\r\n        return function(x,y) {\r\n            var sigma = options['sigma'];\r\n            return Math.exp(-1.*Math.pow(math.getNormVec(math.minusVec(x,y)),2)/(2*sigma*sigma));\r\n        }\r\n    } else if (options['type'] === 'linear') {\r\n        return function(x,y) {\r\n            return math.dotVec(x,y);\r\n        }\r\n    } else if (options['type'] === 'polynomial') {\r\n        return function(x,y) {\r\n            var c = options['c'];\r\n            var d = options['d'];\r\n            return Math.pow(math.dotVec(x,y) + c, d);\r\n        }\r\n    }\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-machine_learning/node_modules/machine_learning/lib/nmf.js":"/**\r\n * Created by joonkukang on 2014. 1. 16..\r\n */\r\nvar utils = require('./utils');\r\nvar math = utils.math;\r\nlet nmf = module.exports;\r\n\r\nnmf.factorize = function(options) {\r\n    var fc = options['features'];\r\n    var matrix = options['matrix'];\r\n    var epochs = options['epochs'];\r\n    var row = math.shape(matrix)[0], col = math.shape(matrix)[1];\r\n    var a = math.randMat(row,fc,0,1);\r\n    var b = math.randMat(fc,col,0,1);\r\n\r\n    var i;\r\n    for(i=0 ; i<epochs; i++) {\r\n        var ab = math.mulMat(a,b)\r\n      //  cost = difcost(ab,matrix);\r\n      //  if(i % 10 ==0) console.log(\"cost \",cost);\r\n      //  if(cost == 0) break;\r\n        var bn = math.mulMat(math.transpose(a),matrix);\r\n        var bd = math.mulMat(math.mulMat(math.transpose(a),a),b);\r\n\r\n        b = math.activateTwoMat(math.mulMatElementWise(b,bn),bd,function(x,y){return x/y});\r\n\r\n        var an = math.mulMat(matrix, math.transpose(b));\r\n        var ad = math.mulMat(math.mulMat(a,b), math.transpose(b));\r\n\r\n        a = math.activateTwoMat(math.mulMatElementWise(a,an),ad,function(x,y){return x/y});\r\n    }\r\n    return [a,b];\r\n}\r\n\r\nfunction difcost(mat1,mat2) {\r\n    var row = math.shape(mat1)[0], col = math.shape(mat1)[1];\r\n    var i , j, difcost=0;\r\n    for(i=0;i<row;i++)\r\n        for(j=0;j<col;j++)\r\n            difcost += Math.pow(mat1[i][j] - mat2[i][j],2);\r\n    return difcost;\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-machine_learning/node_modules/machine_learning/lib/optimize.js":"/**\r\n * Created by joonkukang on 2014. 1. 16..\r\n */\r\nvar math = require('./utils').math;\r\nlet optimize = module.exports;\r\n\r\noptimize.hillclimb = function(options){\r\n    var domain = options['domain'];\r\n    var costf = options['costf'];\r\n\r\n    var i;\r\n    var vec = [];\r\n    for(i=0 ; i<domain.length ; i++)\r\n        vec.push(math.randInt(domain[i][0],domain[i][1]));\r\n\r\n    var current, best;\r\n\r\n    while(true) {\r\n        var neighbors = [];\r\n        var i,j;\r\n\r\n        for(i=0 ; i<domain.length ; i++) {\r\n            if(vec[i] > domain[i][0]) {\r\n                var newVec = [];\r\n                for(j=0 ; j<domain.length ; j++)\r\n                    newVec.push(vec[j]);\r\n                newVec[i]-=1;\r\n                neighbors.push(newVec);\r\n            } else if (vec[i] < domain[i][1]) {\r\n                var newVec = [];\r\n                for(j=0 ; j<domain.length ; j++)\r\n                    newVec.push(vec[j]);\r\n                newVec[i]+=1;\r\n                neighbors.push(newVec);\r\n            }\r\n        }\r\n\r\n        current = costf(vec);\r\n        best = current;\r\n        for(i=0 ; i<neighbors.length ; i++) {\r\n            var cost = costf(neighbors[i]);\r\n            if(cost < best) {\r\n                best = cost;\r\n                vec = neighbors[i];\r\n            }\r\n        }\r\n        if(best === current)\r\n            break;\r\n    }\r\n    return vec;\r\n}\r\n\r\noptimize.anneal = function(options){\r\n    var domain = options['domain'];\r\n    var costf = options['costf'];\r\n    var temperature = options['temperature'];\r\n    var cool = options['cool'];\r\n    var step = options['step'];\r\n    var callback\r\n\r\n    var i;\r\n    var vec = [];\r\n    for(i=0 ; i<domain.length ; i++)\r\n        vec.push(math.randInt(domain[i][0],domain[i][1]));\r\n\r\n    while(temperature > 0.1) {\r\n        var idx = math.randInt(0,domain.length - 1);\r\n        var dir = math.randInt(-step,step);\r\n        var newVec = [];\r\n        for(i=0; i<vec.length ; i++)\r\n            newVec.push(vec[i]);\r\n        newVec[idx]+=dir;\r\n        if(newVec[idx] < domain[idx][0]) newVec[idx] = domain[idx][0];\r\n        if(newVec[idx] > domain[idx][1]) newVec[idx] = domain[idx][1];\r\n\r\n        var ea = costf(vec);\r\n        var eb = costf(newVec);\r\n        var p = Math.exp(-1.*(eb-ea)/temperature);\r\n        if(eb < ea || Math.random() < p)\r\n            vec = newVec;\r\n\r\n        temperature *= cool;\r\n    }\r\n\r\n    return vec;\r\n}\r\n\r\noptimize.genetic = function(options){\r\n    var domain = options['domain'];\r\n    var costf = options['costf'];\r\n    var population = options['population'];\r\n    var q = options['q'] || 0.3;\r\n    var elite = options['elite'] || population * 0.04;\r\n    var epochs = options['epochs'] || 100;\r\n\r\n    var i,j;\r\n    // Initialize population array\r\n    var pop =[];\r\n    for(i=0; i<population; i++) {\r\n        var vec = [];\r\n        for(j=0; j<domain.length; j++)\r\n            vec.push(math.randInt(domain[j][0],domain[j][1]));\r\n        pop.push(vec);\r\n    }\r\n    pop.sort(function(a,b){return costf(a) - costf(b);});\r\n\r\n    for(i=0 ; i<epochs ; i++) {\r\n        // elitism\r\n        var newPop = [];\r\n        for(j=0;j<elite;j++)\r\n            newPop.push(pop[j]);\r\n\r\n        // compute fitnesses\r\n        var fitnesses = [];\r\n        for(j=0; j<pop.length; j++)\r\n            fitnesses[j] = q * Math.pow(1-q,j);\r\n        fitnesses = math.normalizeVec(fitnesses);\r\n\r\n        // crossover, mutate\r\n        for(j=0; j<pop.length - elite;j++) {\r\n            var idx1 = rouletteWheel(fitnesses);\r\n            var idx2 = rouletteWheel(fitnesses);\r\n            var crossovered = crossover(pop[idx1],pop[idx2]);\r\n            var mutated = mutate(crossovered);\r\n            newPop.push(mutated);\r\n        }\r\n\r\n        // replacement\r\n        pop = newPop;\r\n        pop.sort(function(a,b){return costf(a) - costf(b);});\r\n       //console.log(\"Current Cost : \",costf(pop[0]));\r\n    }\r\n    return pop[0];\r\n\r\n    function mutate(vec) {\r\n        var idx = math.randInt(0,domain.length - 1);\r\n        var newVec = [];\r\n        var i;\r\n        for(i=0; i<domain.length ; i++)\r\n            newVec.push(vec[i]);\r\n        newVec[idx] += (Math.random() < 0.5) ? 1 : -1;\r\n        if(newVec[idx] < domain[idx][0]) newVec[idx] = domain[idx][0];\r\n        if(newVec[idx] > domain[idx][1]) newVec[idx] = domain[idx][1];\r\n        return newVec;\r\n    }\r\n    function crossover(vec1,vec2) {\r\n        var idx = math.randInt(0,domain.length - 2);\r\n        var newVec = [];\r\n        var i;\r\n        for(i=0; i<idx ; i++)\r\n            newVec.push(vec1[i]);\r\n        for(i=idx; i<domain.length; i++)\r\n            newVec.push(vec2[i]);\r\n        return newVec;\r\n    }\r\n    function rouletteWheel(vec) {\r\n        var a = [0.0];\r\n        var i;\r\n        for(i=0;i<vec.length;i++) {\r\n            a.push(a[i] + vec[i]);\r\n        }\r\n        var rand = Math.random();\r\n        for(i=0;i< a.length;i++) {\r\n            if(rand > a[i] && rand <= a[i+1])\r\n                return i;\r\n        }\r\n        return -1;\r\n    }\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-machine_learning/node_modules/machine_learning/lib/mlp.js":"/**\r\n * Created by joonkukang on 2014. 1. 14..\r\n */\r\nvar math = require('./utils').math;\r\nlet HiddenLayer = require('./HiddenLayer');\r\nlet MLP = module.exports = function (settings) {\r\n    var self = this;\r\n    self.x = settings['input'];\r\n    self.y = settings['label'];\r\n    self.sigmoidLayers = [];\r\n    self.nLayers = settings['hidden_layer_sizes'].length;\r\n    self.settings = {\r\n        'log level' : 1 // 0 : nothing, 1 : info, 2: warn\r\n    };\r\n    var i;\r\n    for(i=0 ; i<self.nLayers+1 ; i++) {\r\n        var inputSize, layerInput;\r\n        if(i == 0)\r\n            inputSize = settings['n_ins'];\r\n        else\r\n            inputSize = settings['hidden_layer_sizes'][i-1];\r\n\r\n        if(i == 0)\r\n            layerInput = self.x;\r\n        else\r\n            layerInput = self.sigmoidLayers[self.sigmoidLayers.length-1].sampleHgivenV();\r\n\r\n        var sigmoidLayer;\r\n        if(i == self.nLayers) {\r\n            sigmoidLayer = new HiddenLayer({\r\n                'input' : layerInput,\r\n                'n_in' : inputSize,\r\n                'n_out' : settings['n_outs'],\r\n                'activation' : math.sigmoid,\r\n                'W' : (typeof settings['w_array'] === 'undefined')? undefined : settings['w_array'][i],\r\n                'b' : (typeof settings['b_array'] === 'undefined')? undefined : settings['b_array'][i]\r\n            });\r\n        } else {\r\n            sigmoidLayer = new HiddenLayer({\r\n                'input' : layerInput,\r\n                'n_in' : inputSize,\r\n                'n_out' : settings['hidden_layer_sizes'][i],\r\n                'activation' : math.sigmoid,\r\n                'W' : (typeof settings['w_array'] === 'undefined')? undefined : settings['w_array'][i],\r\n                'b' : (typeof settings['b_array'] === 'undefined')? undefined : settings['b_array'][i]\r\n            });\r\n        }\r\n        self.sigmoidLayers.push(sigmoidLayer);\r\n    }\r\n};\r\n\r\nMLP.prototype.train = function(settings) {\r\n    var self = this;\r\n    var lr = 0.6, epochs = 1000;\r\n    if(typeof settings['lr'] !== 'undefined')\r\n        lr = settings['lr'];\r\n    if(typeof settings['epochs'] !== 'undefined')\r\n        epochs = settings['epochs'];\r\n\r\n\r\n    var epoch;\r\n    var currentProgress = 1;\r\n    for(epoch=0 ; epoch < epochs ; epoch++) {\r\n\r\n        // Feed Forward\r\n        var i;\r\n        var layerInput = [];\r\n        layerInput.push(self.x);\r\n        for(i=0; i<self.nLayers+1 ; i++) {\r\n            layerInput.push(self.sigmoidLayers[i].output(layerInput[i]));\r\n        }\r\n        var output = layerInput[self.nLayers+1];\r\n        // Back Propagation\r\n        var delta = new Array(self.nLayers + 1);\r\n        delta[self.nLayers] = math.mulMatElementWise(math.minusMat(self.y, output),\r\n            math.activateMat(self.sigmoidLayers[self.nLayers].linearOutput(layerInput[self.nLayers]), math.dSigmoid));\r\n\r\n        /*\r\n         self.nLayers = 3 (3 hidden layers)\r\n         delta[3] : ouput layer\r\n         delta[2] : 3rd hidden layer, delta[0] : 1st hidden layer\r\n         */\r\n        for(i = self.nLayers - 1; i>=0 ; i--) {\r\n            delta[i] = math.mulMatElementWise(self.sigmoidLayers[i+1].backPropagate(delta[i+1]),\r\n                math.activateMat(self.sigmoidLayers[i].linearOutput(layerInput[i]), math.dSigmoid));\r\n        }\r\n        // Update Weight, Bias\r\n        for(var i=0; i<self.nLayers+1 ; i++) {\r\n            var deltaW = math.activateMat(math.mulMat(math.transpose(layerInput[i]),delta[i]),function(x){return 1. * x / self.x.length;})\r\n            var deltaB = math.meanMatAxis(delta[i],0);\r\n            self.sigmoidLayers[i].W = math.addMat(self.sigmoidLayers[i].W,deltaW);\r\n            self.sigmoidLayers[i].b = math.addVec(self.sigmoidLayers[i].b,deltaB);\r\n        }\r\n\r\n        if(self.settings['log level'] > 0) {\r\n            var progress = (1.*epoch/epochs)*100;\r\n            if(progress > currentProgress) {\r\n                console.log(\"MLP\",progress.toFixed(0),\"% Completed.\");\r\n                currentProgress+=8;\r\n            }\r\n        }\r\n    }\r\n    if(self.settings['log level'] > 0)\r\n        console.log(\"MLP Final Cross Entropy : \",self.getReconstructionCrossEntropy());\r\n};\r\n\r\nMLP.prototype.getReconstructionCrossEntropy = function() {\r\n    var self = this;\r\n    var reconstructedOutput = self.predict(self.x);\r\n    var a = math.activateTwoMat(self.y,reconstructedOutput,function(x,y){\r\n        return x*Math.log(y);\r\n    });\r\n\r\n    var b = math.activateTwoMat(self.y,reconstructedOutput,function(x,y){\r\n        return (1-x)*Math.log(1-y);\r\n    });\r\n\r\n    var crossEntropy = -math.meanVec(math.sumMatAxis(math.addMat(a,b),1));\r\n    return crossEntropy\r\n}\r\n\r\nMLP.prototype.predict = function(x) {\r\n    var self = this;\r\n    var output = x;\r\n    for(i=0; i<self.nLayers+1 ; i++) {\r\n        output = self.sigmoidLayers[i].output(output);\r\n    }\r\n    return output;\r\n};\r\n\r\nMLP.prototype.set = function(property,value) {\r\n    var self = this;\r\n    self.settings[property] = value;\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-machine_learning/node_modules/machine_learning/lib/HiddenLayer.js":"/**\r\n * Created by joonkukang on 2014. 1. 12..\r\n */\r\nvar math = require('./utils').math;\r\nlet HiddenLayer = module.exports = function (settings) {\r\n    var self = this;\r\n    self.input = settings['input'];\r\n\r\n    if(typeof settings['W'] === 'undefined') {\r\n        var a = 1. / settings['n_in'];\r\n        settings['W'] = math.randMat(settings['n_in'],settings['n_out'],-a,a);\r\n    }\r\n    if(typeof settings['b'] === 'undefined')\r\n        settings['b'] = math.zeroVec(settings['n_out']);\r\n    if(typeof settings['activation'] === 'undefined')\r\n        settings['activation'] = math.sigmoid;\r\n\r\n    self.W = settings['W'];\r\n    self.b = settings['b'];\r\n    self.activation = settings['activation'];\r\n}\r\n\r\nHiddenLayer.prototype.output = function(input) {\r\n    var self = this;\r\n    if(typeof input !== 'undefined')\r\n        self.input = input;\r\n\r\n    var linearOutput = math.addMatVec(math.mulMat(self.input,self.W),self.b);\r\n    return math.activateMat(linearOutput,self.activation);\r\n};\r\n\r\nHiddenLayer.prototype.linearOutput = function(input) { // returns the value before activation.\r\n    var self = this;\r\n    if(typeof input !== 'undefined')\r\n        self.input = input;\r\n\r\n    var linearOutput = math.addMatVec(math.mulMat(self.input,self.W),self.b);\r\n    return linearOutput;\r\n}\r\n\r\nHiddenLayer.prototype.backPropagate = function (input) { // example+num * n_out matrix\r\n    var self = this;\r\n    if(typeof input === 'undefined')\r\n        throw new Error(\"No BackPropagation Input.\")\r\n\r\n    var linearOutput = math.mulMat(input, math.transpose(self.W));\r\n    return linearOutput;\r\n}\r\n\r\nHiddenLayer.prototype.sampleHgivenV = function(input) {\r\n    var self = this;\r\n    if(typeof input !== 'undefined')\r\n        self.input = input;\r\n\r\n    var hMean = self.output();\r\n    var hSample = math.probToBinaryMat(hMean);\r\n    return hSample;\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-machine_learning/node_modules/machine_learning/lib/DecisionTree.js":"/**\r\n * Created by joonkukang on 2014. 1. 16..\r\n */\r\nvar utils = require('./utils');\r\nvar math = utils.math;\r\nfunction DecisionNode(options) {\r\n    var self = this;\r\n    self.col = (typeof options['col'] === 'undefined') ? -1 : options['col'];\r\n    self.value = options['value'];\r\n    self.results = options['results'];\r\n    self.tb = options['tb'];\r\n    self.fb = options['fb'];\r\n}\r\nDecisionNode.prototype.print =  function() {\r\n    var self = this;\r\n    printTree(self,'');\r\n}\r\n\r\nlet DecisionTree = module.exports = function (options) {\r\n    var self = this;\r\n    self.data = options['data'];\r\n    self.result = options['result'];\r\n}\r\n\r\nDecisionTree.prototype.build = function(options) {\r\n    var self = this;\r\n    var rows = [];\r\n    var i;\r\n    for(i=0; i<self.data.length; i++) {\r\n        rows.push(self.data[i]);\r\n        rows[i].push(self.result[i]);\r\n    }\r\n    self.tree = buildTree(rows,entropy);\r\n    return self.tree;\r\n};\r\n\r\nDecisionTree.prototype.print = function() {\r\n\r\n    var self = this;\r\n    printTree(self.tree,'');\r\n}\r\n\r\nDecisionTree.prototype.classify = function(observation) {\r\n    var self = this;\r\n    return classify(observation,self.tree);\r\n}\r\n\r\nDecisionTree.prototype.prune = function(mingain){\r\n    var self = this;\r\n    prune(self.tree,mingain);\r\n}\r\n\r\nDecisionTree.prototype.getTree = function() {\r\n    return this.tree;\r\n}\r\n\r\nfunction prune(tree,mingain) {\r\n    if(typeof tree.tb.results === 'undefined')\r\n        prune(tree.tb,mingain);\r\n    if(typeof tree.fb.results === 'undefined')\r\n        prune(tree.fb,mingain);\r\n\r\n    if(typeof tree.tb.results !== 'undefined' && typeof tree.fb.results !== 'undefined') {\r\n        var tb = [], fb = [], tbfb = [];\r\n        Object.keys(tree.tb.results).forEach(function(key) {\r\n            for(var i=0; i<tree.tb.results[key] ; i++) {\r\n                tb.push([key]);\r\n                tbfb.push([key]);\r\n            }\r\n        });\r\n        Object.keys(tree.fb.results).forEach(function(key) {\r\n            for(var i=0; i<tree.fb.results[key] ; i++) {\r\n                fb.push([key]);\r\n                tbfb.push([key]);\r\n            }\r\n        });\r\n        var p = 1.*tb.length / tbfb.length;\r\n        var delta = entropy(tbfb) - p * entropy(tb) - (1-p) * entropy(fb);\r\n        if(delta < mingain) {\r\n            // pruning\r\n            tree.tb = undefined;\r\n            tree.fb = undefined;\r\n            tree.results = uniqueCounts(tbfb);\r\n        }\r\n    }\r\n}\r\n\r\nfunction classify(observaton,tree) {\r\n    if(typeof tree.results !== 'undefined')\r\n        return tree.results;\r\n    else {\r\n        var v = observaton[tree.col];\r\n        var branch;\r\n        if(utils.isNumber(v)) {\r\n            if(v>=tree.value) branch = tree.tb;\r\n            else branch = tree.fb;\r\n        } else {\r\n            if(v === tree.value) branch = tree.tb;\r\n            else branch = tree.fb;\r\n        }\r\n        return classify(observaton,branch);\r\n    }\r\n}\r\n\r\nfunction printTree(tree,indent) {\r\n    indent = indent || '';\r\n    if(typeof tree.results !== 'undefined')\r\n        console.log(tree.results);\r\n    else {\r\n        // print condition\r\n        console.log(tree.col+':'+tree.value+'? ');\r\n\r\n        // print branches\r\n        process.stdout.write(indent + 'T->');\r\n        printTree(tree.tb,indent +'  ');\r\n        process.stdout.write(indent + 'F->');\r\n        printTree(tree.fb,indent +'  ');\r\n    }\r\n}\r\n\r\nfunction buildTree(rows,scoref) {\r\n    if(rows.length == 0) return new DecisionNode();\r\n    var currentScore = scoref(rows);\r\n    var bestGain = 0.0, bestCriteria, bestSets;\r\n    var columnCount = rows[0].length - 1;\r\n    var col, i;\r\n    for(col=0; col<columnCount; col++) {\r\n        var columnValues = {};\r\n        for(i=0; i<rows.length; i++) {\r\n            columnValues[rows[i][col]] = 1;\r\n        }\r\n        var values = Object.keys(columnValues);\r\n        for(i=0; i<values.length; i++) {\r\n            var sets = divideSet(rows,col,values[i]);\r\n            var p = 1.*sets[0].length / rows.length;\r\n            var gain = currentScore - p*scoref(sets[0]) - (1-p)*scoref(sets[1]);\r\n            if(gain > bestGain && sets[0].length > 0 && sets[1].length > 0) {\r\n                bestGain = gain;\r\n                bestCriteria = [col,values[i]];\r\n                bestSets = sets;\r\n            }\r\n        }\r\n    }\r\n    if(bestGain > 0) {\r\n        var trueBranch = buildTree(bestSets[0],scoref);\r\n        var falseBranch = buildTree(bestSets[1],scoref);\r\n        return new DecisionNode({\r\n            col : bestCriteria[0],\r\n            value : bestCriteria[1],\r\n            tb : trueBranch,\r\n            fb : falseBranch\r\n        });\r\n    } else {\r\n        return new DecisionNode({\r\n            results : uniqueCounts(rows)\r\n        });\r\n    }\r\n}\r\n\r\nfunction entropy(rows) {\r\n    var log2 = function(x) {return Math.log(x)/Math.log(2);};\r\n    var results = uniqueCounts(rows);\r\n    var ent = 0.0;\r\n    var keys = Object.keys(results);\r\n    var i;\r\n    for(i=0; i<keys.length; i++) {\r\n        var p = 1.*results[keys[i]]/rows.length;\r\n        ent -= 1.*p*log2(p);\r\n    }\r\n    return ent;\r\n}\r\nfunction uniqueCounts(rows) {\r\n    var results = {};\r\n    var i;\r\n    for(i=0; i<rows.length; i++) {\r\n        var r = rows[i][rows[i].length-1];\r\n        if(typeof results[r] === 'undefined')\r\n            results[r] = 0;\r\n        results[r]++;\r\n    }\r\n    return results;\r\n}\r\nfunction divideSet(rows,column,value) {\r\n    var splitFunction;\r\n\r\n    if(utils.isNumber(value))\r\n        splitFunction = function(row) {return row[column] >= value;};\r\n    else\r\n        splitFunction = function(row) {return row[column] === value;};\r\n    var set1 = [], set2 = [];\r\n    var i;\r\n    for(i=0; i<rows.length; i++) {\r\n        if(splitFunction(rows[i]))\r\n            set1.push(rows[i]);\r\n        else\r\n            set2.push(rows[i]);\r\n    }\r\n    return [set1,set2];\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-machine_learning/node_modules/machine_learning/lib/LogisticRegression.js":"/**\r\n * Created by joonkukang on 2014. 1. 12..\r\n */\r\nvar math = require('./utils').math;\r\nlet LogisticRegression = module.exports = function (settings) {\r\n    var self = this;\r\n    self.x = settings['input'];\r\n    self.y = settings['label'];\r\n    self.W = math.zeroMat(settings['n_in'],settings['n_out']);\r\n    self.b = math.zeroVec(settings['n_out']);\r\n    self.settings = {\r\n        'log level' : 1 // 0 : nothing, 1 : info, 2: warn\r\n    };\r\n};\r\n\r\nLogisticRegression.prototype.train = function (settings) {\r\n    var self = this;\r\n    var lr = 0.1, epochs = 200;\r\n    if(typeof settings['input'] !== 'undefined')\r\n        self.x = settings['input'];\r\n    if(typeof settings['lr'] !== 'undefined')\r\n        lr = settings['lr'];\r\n    if(typeof settings['epochs'] !== 'undefined')\r\n        epochs = settings['epochs'];\r\n    var i;\r\n    var currentProgress = 1;\r\n    for(i=0;i<epochs;i++) {\r\n        var probYgivenX = math.softmaxMat(math.addMatVec(math.mulMat(self.x,self.W),self.b));\r\n        var deltaY = math.minusMat(self.y,probYgivenX);\r\n\r\n        var deltaW = math.mulMat(math.transpose(self.x),deltaY);\r\n        var deltaB = math.meanMatAxis(deltaY,0);\r\n\r\n        self.W = math.addMat(self.W,math.mulMatScalar(deltaW,lr));\r\n        self.b = math.addVec(self.b,math.mulVecScalar(deltaB,lr));\r\n        if(self.settings['log level'] > 0) {\r\n            var progress = (1.*i/epochs)*100;\r\n            if(progress > currentProgress) {\r\n                console.log(\"LogisticRegression\",progress.toFixed(0),\"% Completed.\");\r\n                currentProgress++;\r\n            }\r\n        }\r\n    }\r\n    if(self.settings['log level'] > 0)\r\n        console.log(\"LogisticRegression Final Cross Entropy : \",self.getReconstructionCrossEntropy());\r\n};\r\n\r\nLogisticRegression.prototype.getReconstructionCrossEntropy = function () {\r\n    var self = this;\r\n    var probYgivenX = math.softmaxMat(math.addMatVec(math.mulMat(self.x,self.W),self.b));\r\n    var a = math.mulMatElementWise(self.y, math.activateMat(probYgivenX,Math.log));\r\n    var b = math.mulMatElementWise(math.mulMatScalar(math.addMatScalar(self.y,-1),-1),\r\n        math.activateMat(math.mulMatScalar(math.addMatScalar(probYgivenX,-1),-1),Math.log));\r\n    var crossEntropy = -math.meanVec(math.sumMatAxis(math.addMat(a,b),1));\r\n    return crossEntropy;\r\n};\r\n\r\nLogisticRegression.prototype.predict = function (x) {\r\n    var self = this;\r\n    return math.softmaxMat(math.addMatVec(math.mulMat(x,self.W),self.b));\r\n};\r\n\r\nLogisticRegression.prototype.set = function(property,value) {\r\n    var self = this;\r\n    self.settings[property] = value;\r\n}\r\n"}